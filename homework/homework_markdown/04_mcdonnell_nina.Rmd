---
title: "BIOL 607 Homework 4"
author: "Nina McDonnell"
date: "10/9/2020"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning= FALSE, message = FALSE)

library(tidyr)
library(dplyr)
library(ggplot2)
library(readr)
library(naniar)

download.file(url="https://projects.fivethirtyeight.com/polls-page/president_polls.csv", destfile = "president_polls.csv")
```

### 1. Write a function that takes a vector and returns one bootstrapped sample from said vector. Demonstrate that it works.

```{r 1}
#set seed
set.seed(802)

#Step 1. create vector
frog_mass <- rnorm(100, mean=1.5, sd=.6)
str(frog_mass)

#Step 2. get bootstrapped sample
frog_mass_samp <- sample(frog_mass,
                           size=length(frog_mass),
                           replace = TRUE) 

#Step 3. Write bootstrap as a function

bootstrapped_samp <- function(x){   #for vector x...
  draws <- length(x) #input number of draws here
  boot_sample <- sample(x,   #produce object "mass_sample" that is a sample from vector x, with...
                        size=draws,  #sample size= length
                        replace = TRUE)  #replacement
  
  return(boot_sample)   #return the object "mass_sample"
}

#Step 4. Test it on previously created "frog_mass" vector
testing_bootstrapped_samp <- bootstrapped_samp(frog_mass)
testing_bootstrapped_samp #it works!

#test it on another vector
frog_svl <- rnorm(50, mean=23, sd=3)
testing_bootstrapped_samp_again <- bootstrapped_samp(frog_svl)
testing_bootstrapped_samp_again #it works!
```

### 2. Write a function that given a vector of values a request for some number of bootstraps (let’s call the parameter R), and a sample statistic function (e.g., mean, IQR, etc.) returns R number of values of that statistic. Have it default to R = 1000 and the function is mean. Show this works for 10 bootstrapped replicate draws of a mean from some vector. Do the values look reasonable? Compare to the actual mean of the vector. Make sure you are using the function(s) you wrote in #1

```{r 2}

bootstrapped_stat <- function(x){   #for vector x...
  R <- 1000 #input number of bootstraps here
  draws <- 10 #input number of draws here
  boot_stat <- replicate(R, bootstrapped_samp(x) %>%  #replicate bootstrapped sample from question 1 function
                                  mean()) #input statistic function 
  
  return(boot_stat)   #return the object "mass_sample"
}

#test on frog_mass vector
testing_bootstrapped_stat <- bootstrapped_stat(frog_mass)
testing_bootstrapped_stat #it works!

#check against vector mean 
mean(testing_bootstrapped_stat)
mean(frog_mass) ##it works! these results are quite close. Yes, the values look reasonable.

```

<span style="color: red;"> Yes, the values look reasonable. The actual mean is `r mean(frog_mass)` and the bootstrapped mean is `r mean(testing_bootstrapped_stat)`. </span>

### 3. Write a function that, given a vector of values a request for some number of bootstraps, and a sample statistic function, returns the original value of the statistic as applied to the vector, the mean of the statistic generated by the bootstrapped reps, the upper and lower 95% CI of the bootstrapped statistic (e.g., the 0.025 and 0.975 quantile), and the bias (i.e., the original value of the statistic - the mean of the bootstrapped statistic).

```{r 3}

bootstrapped_mean_ci_bias <- function(x){   #for vector x...
  R <- 1000 #input number of bootstraps here
  draws <- 10 #input number of draws here
  original_vec_stat <- mean(x) #calculate statistic for original vec
  boot_stat <- bootstrapped_stat(x) #get bootstraps of statistic of x using question 2 function
  boot_stat_mean <- mean(boot_stat) #bootstrapped mean= mean of statistic generated by bootstrapped reps
  confidence_interval <- function(x) {
    se <- sd(boot_stat) #SE= SD of statistic generated by bootstrapped reps
    CI <- c("lower" = boot_stat_mean - (1.96*se), "upper" = boot_stat_mean + (1.96*se)) #calculate 95%CI (+- 1.96 SE)
    return(CI)
  }
  
  boot_stat_ci <- confidence_interval(boot_stat)
  bias <- original_vec_stat - boot_stat_mean 
  
  output <- c("bootstrapped statistic mean" = boot_stat_mean, "original vector statistic" = original_vec_stat, "bootstrapped statistic CI" = boot_stat_ci, "bias"= bias)
  return(output)
}

#test on frog_mass vector
testing_bootstrapped_mean_ci_bias <- bootstrapped_mean_ci_bias(frog_mass)
testing_bootstrapped_mean_ci_bias #it works!

```

### 4. FiveThirtyEight keeps a great archive of poll data at https://projects.fivethirtyeight.com/polls/. The presidential general election polling data is freely available at https://projects.fivethirtyeight.com/polls-page/president_polls.csv with question, poll id, and cycle defining a unique poll.

### 4a. Download and look at the data. Is it long or wide?

```{r 4a}
#read in data
pres_polls <- read.csv("president_polls.csv")

str(pres_polls) #The data frame is long. 
#Note: variable classes did not load in correctly. Make sure to mutate them to the appropriate classes before use
miss_var_summary(pres_polls) #summarizes NA data from large data sets. 

```

<span style="color: red;">The data frame is long. </span>


### 4b. Get just the polling data for this last week (from 9/29 to today). Filter on start_date. Also filter down to just Biden and Trump (see candidate_name or answer). Extra credit for using {lubridate} for this, but you can just do a messy %in% string match.

```{r 4b}

library(lubridate) #Using lubridate! (Extra credit)
library(dplyr)

sample <- pres_polls %>% 
  mutate(start_date=mdy(start_date))%>%  #convert date from mm/dd/yyyy to yyyy-mm-dd with mdy() from lubridate
  filter(start_date >= "2020-09-29")%>%  #filter to get dates >= 9/29/20, using new date format from above
  filter(answer == "Trump" | answer == "Biden") #filter polls after 9/29 to include only those with answer of biden OR answer of trump 

#here are the data from 9/29 to present
str(sample)

```

### 4c. OK, this is your sample. What’s the bootstrapped average percentage for each candidate for nationwide polls (state == "")? Note, this answer will not match 538 given their weighting by poll trustworthiness.

```{r 4c}

#first Biden
Biden_sample <- pres_polls%>%
  mutate(start_date=mdy(start_date))%>% #convert date from mm/dd/yyyy to yyyy-mm-dd with mdy() from lubridate
  filter(start_date>="2020-09-29")%>% #filter to get dates >= 9/29/20, using new date format from above
  filter(answer=="Biden")%>% #filter polls after 9/29 to include only those with answer of biden OR answer of trump 
  filter(state=="")%>% #remove state polls
  dplyr::select(answer, pct) 

#then Trump
Trump_sample <- pres_polls%>%
  mutate(start_date=mdy(start_date))%>%
  filter(start_date>="2020-09-29")%>%
  filter(answer=="Trump")%>%
  filter(state=="")%>%
  dplyr::select(answer, pct)

mean(bootstrapped_stat(Biden_sample$pct))

mean(bootstrapped_stat(Trump_sample$pct))

```

<span style="color: red;">The bootstrapped average percentage for Biden is `r mean(bootstrapped_stat(Biden_sample$pct))`. For Trump, it is `r mean(bootstrapped_stat(Trump_sample$pct))`.</span>


### 4d. What is the average difference between the two candidates by state and national polls? Note, you’ll need to make this a wide data frame to answer! And, well, try the pivot without this advice first, but then… make a unique ID by pasting together the question_id, poll_id, and state. Then select the ID, state, answer, and pct. Also filter out NA diffs

```{r 4d}
#make a wide df
polls_wide <- pivot_wider(pres_polls,  
                      names_from = answer,
                      values_from = pct) %>% 
  mutate(ID = paste(question_id, poll_id, state, sep="_")) %>% #add column for unique ID
  dplyr::select(Trump, Biden, state, ID) #select the parts we want to see

#state polls
state_polls <- polls_wide %>% 
  filter(state !="") %>%  #remove national polls
  group_by(state) %>%  #calculate av diff for each state
  summarize(average_diff=mean(Biden, na.rm=TRUE)-mean(Trump, na.rm=TRUE)) %>% #add abs() to get absolute value for difference. Right now, positive= Biden, -Trump
  ungroup() 

#national polls
national_polls <- polls_wide %>% 
  filter(state =="") %>%  #remove state polls
  summarize(average_diff=mean(Biden, na.rm=TRUE)-mean(Trump, na.rm=TRUE)) #add abs() to get absolute value for difference. Right now, positive= Biden, negative =Trump

```

<span style="color: red;">The average differences between candidates for state polls are shown below. Positive values are in Biden's favor and negative values are in Trump's favor. The average difference between candidates for national polls is `r national_polls` (in favor of Biden)  </span>

``` {r 4d-2}
print(state_polls, n=55)
```


### 5. replicate() has been our friend, but we’ve always had to be a little hacky with it. We’ve either had to fold in means, or use tricksy functions like colMeans and the like. BUT - what’s interesting about replicate() is that, if you ask it to turn back raw draws from a random number generator - or anything with more than one value - it gives you a matrix or array.

###  5a. So, I want you to, using the mean and SD of Biden’s national polling average (you’ll need to calculate it!) from above, simulate 1000 draws from that population with a sample size of 50. What are the dimensions of the object. What are in the rows and columns?

```{r 5a}
#set seed
set.seed(802)

mean_pct <- mean(Biden_sample$pct)
sd_pct <- sd(Biden_sample$pct)

R <- 1000
samp_size <- 50

#generate sample of 50 
Biden_poll <- rnorm(samp_size, mean=mean_pct, sd=sd_pct)

#replicate 1000 draws from sample

Biden_poll_sim <- replicate(R, sample(rnorm(samp_size, mean=mean_pct, sd=sd_pct))) #we talked about removing the sample() component of this in office hours, but then it was 1000 repetitions of a single value for pct, so I added it back.

str(Biden_poll_sim) #We get a matrix with 50 rows and 1000 columns

```

<span style="color: red;"> We get a matrix with 50 rows and 1000 columns. There is one column for each simulation and one row for each sampled data point. </span>

### 5b. Yuck. Can you turn this into something usable? Say, first make it a tibble or data frame, and then pivot it to long, such that you end up with a column that has an identifier for sim and a column with a single value from that sim?(Oh, and for all columns, cols = everything())

```{r 5b}

#pivot_longer and name columns by sim number and value
Biden_df <- as.data.frame(Biden_poll_sim)

Biden_df_long <- Biden_df %>% 
  pivot_longer(cols= everything(),
               names_to = "sim")

str(Biden_df_long)

```

### 5c. For each sim, what’s the bootsrapped mean and CI? Plot it! And tell us how often it’s greater than the initial mean. E.C. for the plot showing the stats in order from low to high.

```{r 5c}

#function for bootstrapped mean and CI 
bootstrapped_poll_stats <- function(x){   #for vector x...
  R <- 1000 #input number of bootstraps here
  draws <- length(x) #input number of draws here
  original_vec_stat <- mean(x) #calculate statistic (mean) for original vec
  boot_stat <- replicate(R,
                         sample(x,   #produce object "mass_sample" that is a sample from vector x, with...
                                size=length(draws),  #sample size
                                replace = TRUE %>%  #replacement
                                  mean()))   #input statistic function (mean)
  boot_stat_mean <- mean(boot_stat)
  confidence_interval <- function(x) {
    se <- sd(boot_stat) #calculate 1 SE
    wholeCI <- 2*(se*1.96) #calculate 95%CI (= estimate +/- 1.96 SE)
    CI <- tibble("whole"= wholeCI, "lower" = boot_stat_mean - (1.96*se), "upper" = boot_stat_mean + (1.96*se)) #return tibble with upper and lower CI and the size of the CI ("whole CI")
    return(CI)
  }
  
  boot_stat_ci <- confidence_interval(boot_stat)
  
  output <- tibble("bootstrapped mean" = boot_stat_mean, "bootstrapped CI" = boot_stat_ci) 

  return(output)
}

#test function 
checkfunction <- bootstrapped_poll_stats(frog_mass) #it works

#new df with columns for sim number, bootstrapped mean, and bootstrapped CI
finally <- Biden_df_long %>% 
  group_by(sim)%>% #for each sim...
  summarize(stats=bootstrapped_poll_stats(value)) %>% #use function to get bootstrapped statistic and CI
  ungroup()

#filter to mean values greater than initial mean
finally_above_mean <- Biden_df_long %>% 
  group_by(sim)%>% 
  summarize(stats=bootstrapped_poll_stats(value)) %>% 
  filter(stats$`bootstrapped mean`>mean_pct) %>% 
  ungroup()

#filter to mean values less than initial mean
finally_below_mean <- Biden_df_long %>% 
  group_by(sim)%>% 
  summarize(stats=bootstrapped_poll_stats(value)) %>% 
  filter(stats$`bootstrapped mean`<mean_pct) %>% 
  ungroup()

number_above <- length(finally_above_mean$stats$`bootstrapped mean`)

number_below <- length(finally_below_mean$stats$`bootstrapped mean`)

#plot the bootstrapped mean and CI for each sim - should be an even scatter of points above and below the initial mean, since simulations were based on normal distribution around the initial mean.
finally %>% 
  ggplot(aes(x=stats$`bootstrapped mean`, y=stats$`bootstrapped CI`$whole))+
  geom_point(aes(color=cut(stats$`bootstrapped mean`, c(-Inf, mean_pct, Inf))))+ #different colors for points above and below initial mean
  geom_vline(xintercept=mean_pct, color="red", linetype="dotted", size=1.5)+
  scale_color_manual(name="Boostrapped mean estimate", values=c("blue","purple"), labels=c("< polling average", "> polling average"))+
  labs(x="boostrapped mean (percent)", y="CI of estimate", title= "Boostrapped mean and CI for 1000 simulations \n of Biden's national polling average")+
  theme_bw()

```

<span style="color: red;"> The bootstrapped means from the 1000 simulations fall below the initial mean of `r mean_pct` (red dashed line) in `r number_below` simulations, and above the mean in `r number_above` simulations </span>

### 5d. So…. what is that plot showing? What are the concepts involved?

<span style="color: red;"> The plot is showing that bootstrapped estimates and SE based on simulations of a normal distribution from a given data set will cluster evenly around the initial mean. With enough random samples, a normal distribution of bootstrapped estimates will emerge.  </span>

## <span style="color: red;">*Extra credit:* submitted via GitHub.</span>
### <span style="color: red;">Repository: https://github.com/ninamcdonnell/biol607_mcdonnell/tree/master/homework/homework_markdown
</span>


