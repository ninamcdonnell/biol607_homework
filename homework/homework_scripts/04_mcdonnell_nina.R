#'---------HEADER---------
#'@title Homework 4
#'@author Nina McDonnell
#'@Date 10/9/20

#NOTE: THIS IS NOT A FINAL HOMEWORK SUBMISSION. SEE .RMD FOR GRADING


library(tidyr)
library(dplyr)
library(ggplot2)
library(readr)
library(naniar)

#------Question 1 ----------
#1. Write a function that takes a vector and returns one bootstrapped sample from said vector. Demonstrate that it works.

#Step 1. create vector
frog_mass <- rnorm(100, mean=1.5, sd=.6)
str(frog_mass)

#Step 2. get bootstrapped sample
frog_mass_samp <- sample(frog_mass,
                           size=length(frog_mass),
                           replace = TRUE) 

#Step 3. Write bootstrap as a function

bootstrapped_samp <- function(x){   #for vector x...
  draws <- length(x) #input number of draws here
  boot_sample <- sample(x,   #produce object "mass_sample" that is a sample from vector x, with...
                        size=draws,  #sample size= length
                        replace = TRUE)  #replacement
  
  return(boot_sample)   #return the object "mass_sample"
}

#Step 4. Test it on previously created "frog_mass" vector
testing_bootstrapped_samp <- bootstrapped_samp(frog_mass)
testing_bootstrapped_samp

#test it on another vector
frog_svl <- rnorm(50, mean=23, sd=3)
testing_bootstrapped_samp_again <- bootstrapped_samp(frog_svl)
testing_bootstrapped_samp_again

#------Question 2 ----------
#2. Write a function that given a vector of values a request for some number of bootstraps 
#(let’s call the parameter R), and a sample statistic function (e.g., mean, IQR, etc.) 
#returns R number of values of that statistic. Have it default to R = 1000 and the function is mean. 
#Show this works for 10 bootstrapped replicate draws of a mean from some vector. Do the values look reasonable? 
#Compare to the actual mean of the vector.

bootstrapped_stat <- function(x){   #for vector x...
  R <- 1000 #input number of bootstraps here
  draws <- 10 #input number of draws here
  boot_stat <- replicate(R,
                           sample(x,   #produce object "mass_sample" that is a sample from vector x, with...
                                  size=length(draws),  #draw 10
                                  replace = TRUE %>%  #replacement
                                    mean())) #input statistic function 

  return(boot_stat)   #return the object "mass_sample"
}

# Use this paired-down version for final...

bootstrapped_stat <- function(x){   #for vector x...
  R <- 1000 #input number of bootstraps here
  draws <- 10 #input number of draws here
  boot_stat <- replicate(R, bootstrapped_samp(x) %>%  #replicate bootstrapped sample from question 1 function
                                  mean()) #input statistic function 
  
  return(boot_stat)   #return the object "mass_sample"
}


#test on frog_mass vector
testing_bootstrapped_stat <- bootstrapped_stat(frog_mass)
testing_bootstrapped_stat

#check against vector mean 
mean(testing_bootstrapped_stat)
mean(frog_mass) #these results are quite close. Yes, the values look reasonable.

#------Question 3 ----------

#3. Write a function that, given a vector of values a request for some number of bootstraps, 
#'and a sample statistic function, returns the original value of the statistic as applied to the vector, 
#'the mean of the statistic generated by the bootstrapped reps, the upper and lower 95% CI of the bootstrapped 
#'statistic (e.g., the 0.025 and 0.975 quantile), and the bias (i.e., the original value of the statistic - 
#'the mean of the bootstrapped statistic).

#CHECK FORMULA FOR ERROR! FOR SOME REASON THE VERSION OF THIS THAT USES THE Q2 EQUATION WAS DIFFERENT CI/BIAS FROM THE LONG-HAND VERSION


bootstrapped_mean_ci_bias <- function(x){   #for vector x...
  R <- 1000 #input number of bootstraps here
  draws <- 10 #input number of draws here
  original_vec_stat <- mean(x) #calculate statistic for original vec
  boot_stat <- replicate(R,
                         sample(x,   #produce object "mass_sample" that is a sample from vector x, with...
                                size=length(draws),  #draw 10
                                replace = TRUE %>%  #replacement
                                  mean()))   #input statistic function 
  boot_stat_mean <- mean(boot_stat)
  confidence_interval <- function(x) {
    se <- boot_stat_mean/sqrt(length(boot_stat)) #calculate 1 SE
    CI <- c("lower" = boot_stat_mean - (1.96*se), "upper" = boot_stat_mean + (1.96*se)) #calculate 95%CI (+- 1.96 SE)
    return(CI)
  }
  
  boot_stat_ci <- confidence_interval(boot_stat)
  bias <- original_vec_stat - boot_stat_mean
  
  output <- c("bootstrapped statistic mean" = boot_stat_mean, "original vector statistic" = original_vec_stat, "bootstrapped statistic CI" = boot_stat_ci, "bias"= bias)
  return(output)
}


#test on frog_mass vector
testing_bootstrapped_mean_ci_bias <- bootstrapped_mean_ci_bias(frog_mass)
testing_bootstrapped_mean_ci_bias

#confidence_interval(frog_mass) #confirms that function is referencing boot_stat for CI and not the original vec

#use this paired-down version for final

bootstrapped_mean_ci_bias <- function(x){   #for vector x...
  R <- 1000 #input number of bootstraps here
  draws <- 10 #input number of draws here
  original_vec_stat <- mean(x) #calculate statistic for original vec
  boot_stat <- bootstrapped_stat(x) #get bootstraps of statistic of x using question 2 function
  boot_stat_mean <- mean(boot_stat) #bootstrapped mean= mean of statistic generated by bootstrapped reps
  confidence_interval <- function(x) {
    se <- sd(boot_stat) #SE= SD of statistic generated by bootstrapped reps
    CI <- c("lower" = boot_stat_mean - (1.96*se), "upper" = boot_stat_mean + (1.96*se)) #calculate 95%CI (+- 1.96 SE)
    return(CI)
  }
  
  boot_stat_ci <- confidence_interval(boot_stat)
  bias <- original_vec_stat - boot_stat_mean
  
  output <- c("bootstrapped statistic mean" = boot_stat_mean, "original vector statistic" = original_vec_stat, "bootstrapped statistic CI" = boot_stat_ci, "bias"= bias)
  return(output)
}


#------Question 4----------

#4a. Download and look at the data. Is it long or wide? - Data are long

pres_polls <- read.csv("homework/homework_data/president_polls.csv")

str(pres_polls) #variable classes are all jumbled up. Make sure to mutate them to the appropriate classes before use
miss_var_summary(pres_polls) #summarizes NA data from large data sets. 

#'4b. Get just the polling data for this last week (from 9/29 to today). Filter on start_date. 
#'Also filter down to just Biden and Trump (see candidate_name or answer). Extra credit for using 
#'{lubridate} for this, but you can just do a messy %in% string match.

library(lubridate) #Using lubridate! (Extra credit)
library(dplyr)

sample <- pres_polls %>% 
  mutate(start_date=mdy(start_date))%>%  #convert date from mm/dd/yyyy to yyyy-mm-dd with mdy() from lubridate
  filter(start_date >= "2020-09-29")%>%  #filter to get dates >= 9/29/20, using new date format from above
  filter(answer == "Trump" | answer == "Biden") #filter polls after 9/29 to include only those with answer of biden OR answer of trump 

sample
str(sample)

#'4c. OK, this is your sample. What’s the bootstrapped average percentage for each candidate for nationwide polls 
#'(state == "")? Note, this answer will not match 538 given their weighting by poll trustworthiness.

#first Biden
Biden_sample <- pres_polls%>%
  mutate(start_date=mdy(start_date))%>% #convert date from mm/dd/yyyy to yyyy-mm-dd with mdy() from lubridate
  filter(start_date>="2020-09-29")%>% #filter to get dates >= 9/29/20, using new date format from above
  filter(answer=="Biden")%>% #filter polls after 9/29 to include only those with answer of biden OR answer of trump 
  filter(state=="")%>% #remove polls
  dplyr::select(answer, pct) 

#then Trump
Trump_sample <- pres_polls%>%
  mutate(start_date=mdy(start_date))%>%
  filter(start_date>="2020-09-29")%>%
  filter(answer=="Trump")%>%
  filter(state=="")%>%
  dplyr::select(answer, pct)

mean(bootstrapped_stat(Biden_sample$pct))

mean(bootstrapped_stat(Trump_sample$pct))


#4d. What is the average difference between the two candidates by state and national polls? Note, you’ll need to make this a wide data 
#frame to answer! And, well, try the pivot without this advice first, but then….

#make a unique ID by pasting together the question_id, poll_id, and state. Then select the ID, state, answer, and pct. Also filter out NA diffs
  
polls_wide <- pivot_wider(pres_polls,  
                      names_from = answer,
                      values_from = pct) %>% 
  mutate(ID = paste(question_id, poll_id, state, sep="_")) %>% 
  dplyr::select(Trump, Biden, state, ID)

#state polls
polls_wide %>% 
  filter(state !="") %>%  #remove national polls
  group_by(state) %>%  #calculate av diff for each state
  summarize(average_diff=mean(Biden, na.rm=TRUE)-mean(Trump, na.rm=TRUE)) #add abs() to get absolute value for difference. Right now, positive= Biden, -Trump

#national polls
polls_wide %>% 
  filter(state =="") %>%  #remove state polls
  summarize(average_diff=mean(Biden, na.rm=TRUE)-mean(Trump, na.rm=TRUE)) #add abs() to get absolute value for difference. Right now, positive= Biden, -Trump

#5a. So, I want you to, using the mean and SD of Biden’s national polling average (you’ll need to calculate it!) 
#from above, simulate 1000 draws from that population with a sample size of 50. What are the dimensions of the object. 
#What are in the rows and columns?

mean_pct <- mean(Biden_sample$pct)
sd_pct <- sd(Biden_sample$pct)

R <- 1000
samp_size <- 50

#generate sample of 50 
Biden_poll <- rnorm(samp_size, mean=mean_pct, sd=sd_pct)

#replicate 1000 draws from sample

Biden_poll_sim <- replicate(R, sample(rnorm(samp_size, mean=mean_pct, sd=sd_pct))) #we talked about removing the sample() component 
#of this in office hours, but I realized that then its just 1000 repetitions of a single value for pct, so I added this back.


str(Biden_poll_sim) #We get a matrix with 50 rows and 1000 columns

#5b. Yuck. Can you turn this into something usable? Say, first make it a tibble or data frame, 
#and then pivot it, such that you end up with a column that has an identifier for sim and a 
#column with a single value from that sim?

#pivot_longer and name columns by sim number and value
Biden_df <- as.data.frame(Biden_poll_sim)

Biden_df_long <- Biden_df %>% 
  pivot_longer(cols= everything(),
               names_to = "sim")

str(Biden_df_long)

#5c. For each sim, what’s the boostrapped mean and CI? Plot it! And tell us how often it’s 
#greater than the initial mean. E.C. for the plot showing the stats in order from low to high.

#function for bootstrapped mean and CI 
bootstrapped_poll_stats <- function(x){   #for vector x...
  R <- 1000 #input number of bootstraps here
  draws <- length(x) #input number of draws here
  original_vec_stat <- mean(x) #calculate statistic for original vec
  boot_stat <- replicate(R,
                         sample(x,   #produce object "mass_sample" that is a sample from vector x, with...
                                size=length(draws),  #draw 10
                                replace = TRUE %>%  #replacement
                                  mean()))   #input statistic function 
  boot_stat_mean <- mean(boot_stat)
  confidence_interval <- function(x) {
    se <- sd(boot_stat) #calculate 1 SE
    wholeCI <- 2*(se*1.96) #calculate 95%CI (+- 1.96 SE)
    CI <- tibble("whole"= wholeCI, "lower" = boot_stat_mean - (1.96*se), "upper" = boot_stat_mean + (1.96*se)) #calculate 95%CI (+- 1.96 SE)
    return(CI)
  }
  
  boot_stat_ci <- confidence_interval(boot_stat)
  
  output <- tibble("bootstrapped mean" = boot_stat_mean, "bootstrapped CI" = boot_stat_ci)

  return(output)
}

checkfunction <- bootstrapped_poll_stats(frog_mass)

#new df with columns for sim number, bootstrapped mean, and bootstrapped CI
finally <- Biden_df_long %>% 
  group_by(sim)%>% #for each sim...
  summarize(stats=bootstrapped_poll_stats(value)) %>% 
  ungroup()

#filter to mean values greater than initial mean
finally_above_mean <- Biden_df_long %>% 
  group_by(sim)%>% #for each sim...
  summarize(stats=bootstrapped_poll_stats(value)) %>% 
  filter(stats$`bootstrapped mean`>mean_pct) %>% 
  ungroup()

#filter to mean values less than initial mean
finally_below_mean <- Biden_df_long %>% 
  group_by(sim)%>% #for each sim...
  summarize(stats=bootstrapped_poll_stats(value)) %>% 
  filter(stats$`bootstrapped mean`<mean_pct) %>% 
  ungroup()

number_above <- length(finally_above_mean$stats$`bootstrapped mean`)

number_below <- length(finally_below_mean$stats$`bootstrapped mean`)

#plot 
finally %>% 
  ggplot(aes(x=stats$`bootstrapped mean`, y=stats$`bootstrapped CI`$whole))+
  geom_point(aes(color=cut(stats$`bootstrapped mean`, c(-Inf, mean_pct, Inf))))+
  geom_vline(xintercept=mean_pct, color="red", linetype="dotted", size=1.5)+
  scale_color_manual(name="Boostrapped mean estimate", values=c("blue","purple"), labels=c("< polling average", "> polling average"))+
  labs(x="boostrapped mean (percent)", y="CI of estimate", title= "Boostrapped mean and CI for 1000 simulations \n of Biden's national polling average")+
  theme_bw()

#first, I want to make a function that returns 2 values from a vector
                    
func <- function(x){
  mean <- mean(x)
  sd <- sd(x)
  output <- tibble("mean"= mean, "sd"= sd)
  return(output)
}

#second, I want to incorporate both the mean and sd from the function 
#output into a long data frame, such that each group has an associated mean and sd

#starting data frame
df <- data.frame(group1= c(1,24,5,67,2),
                 group2= c(4,5,6,7,8),
                 group3= c(34,56,37,38,24),
                 group4= c(12,34,23,22,15)) %>% 
  pivot_longer(cols= everything(),
               names_to = "group")

#new data frame with mean and sd for each group
new_df <- df %>% 
  group_by(group) %>% 
  summarise(stats=func(value)) %>% 
  ungroup() 
#how do I set this up to get one column for mean and one for sd?
